# ee2361
A basic set of droid commands for the PIC24, and some fundamental hardware.
EE 2361: Introduction to Microcontroller 
Final Project 
Nathan Raab
Chee Tey
Grant Udstrand
Webster Wing
May 4, 2018

Github Link: https://github.com/FatherNelson/ee2361

Introduction 

	The library used in this project is an offshoot of a common project attempted in Arduino, with some critical differences. Namely, the PIC24 is the primary chip used, which in and of itself is a vastly different register mapping to Arduino, without various avr programming assistants such as the package “avrdude” used by the arduino platform, thus the code they used was not usable on the PIC platform. Beyond that, many of these libraries were insufficient to handle bluetooth operation, and none supported multiple velocities. It should be noted that one video of a preliminary test of an RC car with a PIC24 was found, but it gave no indication of how or what was necessary to accomplish these tasks. It also did not include any code, and attempted to implement its idea with IR instead of bluetooth. Therefore, the uniqueness resides in making the bluetooth car run over bluetooth at multiple velocities using a fabricated chassis. The base board and motor mounts were purchased, as well as the batteries, but the side walls and the breadboarding were unique circuitry. 
	There were three main module files, the motor driver, the bluetooth-UART interpreter, and the ultrasonic scanner. All of the files below are defined by a “defs” file which defines a series of ISR’s and setup functions for the modules thus the body of the indefinite loop has no contents. The ISR’s will henceforth be described since they are the drivers of the program, and their vector name is provided as it is in the code base. Each definition file is tied to the main header file and the main function exists in robo_run.c. Descriptions of these files are below starting with robo_run.c

Robo_run.c:
	This file contains the definition of main and does boilerplate configurations of the chip such as disengaging the watchdog timer, engaging pll, etc. This file calls the setup functions defined in their own defs file which then drive by interrupt. It only calls globally accessible functions and provides the context for main. How individual pragmas are assigned is detailed in the file itself, but otherwise, this is a very rudimentary segment which does nothing but call the setup functions. 
Functions:
	void setup_scan() : Initialize the pin definitions for the HC-SR04 and turn on the pertinent interrupts. In this case, it defines INT0, INT1, and INT2, the three external interrupts used by the scanner to measure wave pulses and OC1, the output compare used to send the trigger.
	
	void setup_motors() : Defines the pinouts to the H-bridge by creating four output compares put on four pins connected to said H-bridge. It also defines the PWM width to be used by all these pins that are going to drive the motor. The “SPEED_ARRAY” is also created which is simply a placeholder of values that vary the time the 0-side of the motor is at zero and how long it is at one. The longer a OC opposite a pin driven high is at zero, the faster the tire will spin. It also guarantees that on startup there is no motion by making all ports on the H-bridge the same polarity (1)
	
	void setup_uart() : Instantiates the pinout definitions for the HC-05 to the PIC24, and creates a protocol for commands. It engages interrupts, sets the baud rate to 9600, and by engaging the interrupts makes the ISR for reading the bluetooth commands in (_U1RXInterrupt) valid. Inside this ISR is a case switch statement where extended commands may be added. A more detailed description of these commands is in the bluetooth_defs.c file below.

Robot.h
	This file provides all globally accessible variables and constants to bridge between robo_run and all the individual modules. It is easy to determine that this is the file where all future modules function calls will be stored. By putting motor functions in the header, any file that uses robot.h achieves the ability to make steering calls anywhere. It also grabs the functions that establish ISR’s in the ISR driven program. The individual functions are defined in robot.h. 

Functions:

	int getXStatus(): These two functions simply return the status of the front or rear sensors as a bool, either “too close” or “normal” in this negative feedback system. Called by functions to determine whether a stop is necessary or not if in help mode.
	
	int getTurnX(): These functions simply return the status of the front left or right sensors as a bool, either close to an obstacle and should turn away or resume typical action. Called by functions to determine whether a turn is best suited to avoid a collision in help mode.
	
	void setUserMode(): Function that puts the robot either in the assisted driving or “master” mode (i.e. if the sensors will change the robot’s direction or not)
	
	void setup_uart(), setup_scanner(), setup_motors(): See roborun.c to get a description of these functions. Essentially define pinouts and instantiate interrupts for the interrupt driven system.
	
	void right(), left(), forward(), rear() : Exactly as they sound, the basic directions the user can instruct the robot to perform via slip-steering.
	
	void autoForward(), autoReverse() : Basic cruise control, defined in depth in OC_MOTO_defs.c
	
	void speedUp(), speedDown(): Change the index that OC_MOTO uses for duty cycles in the speed array. By increasing the index, the user picks a longer duty cycle on the negative side of the current direction increasing speed. By decreasing the index, the inverse occurs.
	
	int getAvgDistLeft(), getAvgDistRight() : Currently unused functions, but they calculate the average of all the distance measurements by the front and rear sensors. To be used in a future application. 

Bluetooth_defs.c
	This file is where the incoming uart signals from the HC-05 are evaluated. Note that either the HC-05 or HC-06 are valid devices for this code. The HC-05 will send a char from whatever terminal program feeds it to the PIC at 9600 baud and the PIC24 will interpret. It uses two global variables, one that defines the entrance to user mode and the other defines the character which was sent. In the bluetooth code is a switch statement which takes the character sent by the HC and calls functions based on what this command is supposed to do and/or resets variables. In all modules, there were attempts to keep code as localized as possible such as calling the function “speedUp” in bluetooth to actually change the index in the array defining speed values inside of the OC_moto_defs file which defines the functions which define motion. Regardless, this file contains the global function “setup_uart” that defines the UART connection to the PIC and allows for the transmission of chars to the PIC, the reader is advised to see the code to observe the setup for it is intuitive. The user may also wish to examine the image below for a full spectrum of what the current commands intend for the PIC to do.

Figure 1: A summary of all the commands available in Version 1

Functions:
	setup_uart() : Procedural UART setup, establishes the baud rates, defines the RX and TX pins, and engages the interrupts for TX/RX. No transmissions were implemented in version 1, but future iterations may use this to give status updates to the user.
	_U1RXInterrupt: The name of the function is a protected vector in PIC. Essentially this function is where the incoming UART chars from the HC-05 or HC-06 are received. A case-switch statement uses the char received to do any number of actions highlighted in the diagram above. If the car is not in user mode, it will enable one of the interrupts, which will then scan the vicinity for obstacles. If the user is in help mode and is moving forward or backward with w or s, the car will check if an obstacle was sensed that should be of concern from motiondetect. If so, it will not allow the user to move forward or backward. If the user is turning, the interrupts are disabled because the car turns by rotating, meaning it should not be able to crash into anything since it is not changing its position, only its orientation. Also, turning may be required to escape from several obstacles in close vicinity. 

		

OC_MOTO:
This file is the file that contains all the code for the robot car’s movements,speed variation, and mode of operation. The basic movements such as forward, reverse, left, and right are done by utilizing output compare with pulse width modulation. To give an overview of the setup, OC2, OC3, OC4, and OC5 correspond to left motor reverse, left motor forward, right motor backward, and right motor forward respectively; for the output pins, RB4, RB9, RB5, and RB3 correspond to left forward, left reverse, right forward, and right reverse respectively. When pins RB4, RB9, RB5, and RB3 are all set to 1’s, the motors are disengage and the droid stays idle. In other words, all 1’s make the pins go to the side with low voltage, resulting in a lack of movement. In addition, Timer 2 and Timer 4 are utilized in these functions. Specifically, Timer 2 is used to set up the output compare functions and Timer 4 is used to implement the robot car’s movement function. In order to set up the output compare functions, Timer 2 is used, peripheral pins are selected as aforementioned, PWM mode is enabled without faults, and lastly Timer 2 enabled. This similar procedure is done for all the four OC’s used. For the basic movements such as forward, the corresponding RB’s are set to allow for desired movement. Furthermore, two if statements are used to avoid obstacles, namely steering to the right when an obstacle is detected on its left and vice versa. The other basic movement functions are similar to that of forward only without obstacle avoidance capabilities as the driver is not anticipated to require such sophistication. The stop function sets the speed of all motors to 0 (idle) thus bringing the robot car to a halt. With the movements of the robot car covered, the robot car also comes with 5 speed variations. The speedUp function switches the speed of the robot car to the next higher speed level. It contains an if statement to cap the maximum speed of the robot car. In other words, continuous speedUp function calls will result in the robot car moving at a constant maximum speed. On the other hand, the speedDown function switches the speed of the robot car to the next lower speed level. It contains an if statement to ensure that continuous speedDown function calls will result in the robot car moving at its lowest possible speed, never coming to a full stop. In order to stop the robot car, the stop function is used instead. Lastly, the user mode of operation can be set to assisted (help mode) or unassisted (user mode). When the robot car is in user mode, all the if statements for obstacle avoidance in the droid’s movement will result in a Boolean false. This will grant the driver full human input without any intervention from the software’s part. The opposite is true when the robot car is in help mode. 

Functions and Important Constants:
MOTOR_WIDTH: Value which defines the duty cycle of the PWM signal to the motors.
SPEED_ARRAY: Stores all the possible speeds from 0 to MAX_SPEED
MAX_SPEED: Indicates the number of elements in SPEED_ARRAY. Default duty cycle of the motors on start up is this index in SPEED_ARRAY which should be a zero.
int unassisted: Indicator variable as to whether or not the vehicle is in assisted mode.
void setupOC2(), setupOC3(), setupOC4(), setupOC5(): Boilerplate output capture definitions. They are all used as PWM motor drivers that take on a value of “1” on the opposite side the tire is intended to rotate. They are initialized at the maximum possible speed (duty cycle of zero). These functions are then manipulated during the functioning of the vehicle to slip-steer at different velocities.
void setupTMR2(), setupTMR4(): Boilerplate timer instantiations. TMR2 is used for the PWM output compares affixed to the tires with a duty cycle specified by MOTOR_WIDTH, and TMR4 maintains the time context so that a user must hold a particular key to continue locomotion in that direction. That is to say, that any input will only act for 1mS before the car defaults to a stop condition if it is not getting a key input.This is to ensure the user is holding down the key for either forward, reverse, or turning left or right. The user can avoid this constraint by using the cruise control. 
void setUserMode(): Function to define whether to operate in assisted mode or “master” mode. These modes are discussed in the basic operation guide.
void setup_motors(): Function that calls all module instantiations. Timer and output compares and their interrupts are called here. All pins of the H-Bridge are written high to avoid any accidental motion on startup.
void speedUp(), speedDown(): Functions that when called change the location of the index in SPEED_ARRAY. The SPEED_ARRAY will hold values in decreasing order of magnitude, as the fastest one can move is when one side of the bridge is high and the other is low with 100% duty cycle. Since the h-bridge and transistor circuit functions as a logic inverter, the fastest speed will occur with a 0% duty cycle. These functions are called by bluetooth.h by pressing “p” and “o” respectively. 
void forward(), reverse(), right(), left(): These functions all start by calling a “startup block”, that is, they bias the motors in a particular direction on startup befitting that direction. For example, to move forward, the H-bridge connections to the front left and front right tire would have to be biased low and the rear biased high. It is possible to drive digitally like this, and this is what was done in the prototyping phase, however, for the OC version, it prevented a latch up on startup of that particular direction. The user is advised to remove the logic below the first four lines during testing of their device, for these lines serve as a proof of motor operation.
void autoForward(), autoReverse(): Cruise control in either the forward or reverse direction. Essentially it says drive forward indefinitely, and if in help mode, make adjustments if a obstacle is determined an imminent threat. 
void stop(): A function that sets all the H-bridge pins to a high polarity to stop rotation of any tire in any direction. At the velocity this vehicle moved, and given it’s steering, it did not make sense to add a braking mechanism in version one beyond a simple hard stop.

Motiondetect_defs.c:
This function contains the code to implement all three ultrasonic sensors, as well as how each of these should be interpreted by the robot. It contains several get() functions that return important data which will be used by the motors. It lists three functions called setOutput_xxx, where xxx is the three directions the sensors point. It also has timers which are used to specify the time between sensors scans, detect how long it has been since the car saw an obstacle, and a timer used in a similar manner to input capture to measure the timestamp accurately by accounting for overflows. It sends out the trigger to all of the sensors for one cycle times the 256 prescaler, or 16 microseconds, every time the output compare overflows. However, it only reads one of the three interrupts because of interference issues and to avoid excessive time in the interrupts. It stores the most recent readings on each respective sensor in a buffer of size 9 for the front sensors, and size 6 for the back sensors. If it sees that too many readings are within a certain threshold, the car will take action to avoid a collision. This threshold was set to 4 out of the most recent readings for the reverse, and 5 for the front two sensors. However, this can be adjusted based on how particular the sensors should be. If it is “close but not too close”, or within approximately 60 cm of an obstacle, it will attempt to turn away. If it extremely close, or within approximately 30 cm of the obstacle, it will simply stop the whole car to avoid a collision. It then refuses to move the car for approximately 750 ms after, which is enough time to determine if the obstacle is still present or if it has moved.
Functions and Overhead:
	Before functions are discussed, there are several variables and declarations that must be discussed. The value of TRIG_WIDTH was used to define the length that should be assigned to the output compare period. The value of TRIG_PAT was used to define the duty cycle of the output compare. Since the transistor circuits shorted the trigger to ground when the gate voltage was high, TRIG_PAT was set to be one less than the total TRIG_WIDTH period, so that the sensor would trigger for only one timer cycle. In addition, the turnaway distance and autostop distance were set to the values listed mostly according to trial and error. According to the datasheet, these values divided by 58 correspond to the distance in cm from an obstacle. Thus, these are approximately 30 and 60 cm. Finally, the noise tolerance was mostly trial and error as well, as the echo line of the sensor often had some extraneous values that should be thrown out. This functions similar to a debouncer with a button. The detectFront/Back and turnLeft/Right variables are used as booleans to determine whether the car should stop or turn away due to an obstacle in its proximity. 

void __attribute__((__interrupt__,__auto_psv__)) _OC1Interrupt(void): This function was considered to be used for some logic to switch between which sensor was activated instead of just which sensor was read. In the end, it was kept for sanity’s sake, but did not do anything.
int getFrontStatus(): This function simply returns the value of detectFront, allowing the other C files to tell whether an obstacle is in close proximity and the car should stop.
int getBackStatus(): This function is similar to the previous, returning the value of detectBack and allowing other files to see whether the car should stop.
void __attribute__((__interrupt__,__auto_psv__)) _T1Interrupt(void): This function was used to tell whether the timer has overflowed since the last reading. This is important because timer 1 was used for timestamping the interrupts, so the overflow check was necessary so that the distance between timestamps would not accidently be recorded as negative if the timer overflowed but that overflow was not recorded.
void __attribute__((__interrupt__,__auto_psv__)) _T3Interrupt(void): This interrupt was declared but not used. Initially it was planned to be used for some sort of logic on which sensor to activate, but this would have required modification to the physical circuit.
void __attribute__((__interrupt__,__auto_psv__)) _T5Interrupt(void): This function was used to determine the time since an obstacle was found. It was set to 750 ms, so that the car would not be allowed to move if an obstacle was observed in the last 750ms. It then sets the flags detectFront and detectBack to 0 so that it does not think that an obstacle is still present. It turns the timer off when done so that the timer can be turned on only when necessary, which is when an obstacle is found.
void setupOC1(void): This is the setup function for OC1. OC1 is used for the trigger signal to the ultrasonic sensors.PPS is set to bind RB6 to the OC1. OC1 is setup by setting OC1R and OC1RS to the TRIG_PAT, as specified above as well. The OC is set as a PWM without faults so that the motors can have their duty cycle adjusted, and thus their speed. Timer 3 is assigned as the OC1 timer. Timer 3 and OC1 interrupt enables were then set, and the timer was turned on.
void setupTMR3(void):  This function initializes the timer 3 for OC1. It first sets the trigger up as a digital output, then declares the timer 3 to be used with OC1. It sets timer 3 to 256 prescaler and sets the PR3 to the TRIG_WIDTH that was specified above, giving a total frequency of approximately 16.62 hz. This is because the sensor has a limit of 17hz, and this TRIG_WIDTH was used because it was the first with negligible interference. 
void setupTMR5(void): This function sets up timer 5 for use as the check for how long an obstacle has been observed. It is set up in the same way as timer 3 except with a different PR5. It has a prescaler of 256, thus giving a PR5 that corresponds to 750ms. The timer 5 interrupt was enabled and the flag was initialized to 0. It was turned off because it should only be enabled when an obstacle is observed.
void setupTMR1(void): This function was used as an overflow timer, and was used to store the timestamp of the echo from the ultrasonic sensor. It had its prescaler set to 1 because this was more accurate for recording the echo timestamps, because it had a higher resolution. PR1 was set to 0xFFFF which corresponded to a time of approximately 4 milliseconds. This means that an overflow is expected in many cases of the timestamp recordings.The timer was initialized to 0, the interrupt flag initialized to 0, the interrupt enabled, and the timer was started.
void __attribute__((__interrupt__,__auto_psv__)) _INT0Interrupt(void): This function, along with the variables declared immediately above it, recorded the timestamp and decided how far away an obstacle was from the front right sensor. It first recorded a rising edge on the echo signal from the sensor, which corresponds to the position of the beginning of the echo pulse. It then stores this as the rise variable. When the echo pulse goes back from 1 to 0, it stores the current value of timer 1 at the falling edge of this pulse, then resets the overflow to zero. It then turns off the int0 interrupt and enables int2, because it should switch between sampling the front right and left sensors. It then calls the function setOutput_Right(), which decides what to do with the values recorded here. Finally, it switches the edge polarity, which is how it decided whether it was sampling the rising or falling edge. It then resets the interrupt flag. 
void __attribute__((__interrupt__,__auto_psv__)) _INT1Interrupt(void): This function is very similar to the int0 function with a few minor differences. This function also records the rising and falling edges as specified in int0, except these are stored in variables called sigma and delta, respectively. It also uses the timer overflow as specified above, and calls the setOutput_rear() function as int1 is tied to the rear sensor. It finally switches the edge polarity, ensures that the interrupt is enabled, and resets the interrupt flag.
void __attribute__((__interrupt__,__auto_psv__)) _INT2Interrupt(void): This function is the same as the int0 function, except with references to int0 and int2 switched. It records the rising and falling edge as alpha and beta, respectively. It switches the next sampled interrupt back to int0, and calls setOutput_left() after measuring the falling edge. It finally switches the edge polarity and resets the interrupt flag.
void setupINT0(void): This is the setup function for int0. It sets rb7 as the input to the interrupt pin for the front right sensor’s echo line. It then enables the interrupt. It sets the edge polarity on the first check to measure the rising edge, as this will be the first signal it receives. It then initializes the interrupt flag to zero. It does not need to change PPS because INT0 is set to work on RB7. 
void setupINT1(void): This is the setup function for in1. It works similar to int0, except with different pins as well as the use of PPS. It sets TRISB so that RB 13 is the input for the rear sensor echo line, then modifies PPS so that RB13 will be read as int1. The int is not enabled since only one sensor should be read at a time, so the default enabled sensor is set as int0. The edge polarity is set to read the first rising edge, and the interrupt flag is initialized to zero.
void setupINT2(void): This is the setup for int2, and works similar to the previous two setups. It sets RB10 as the input to the front left echo line of the front left sensor, and modifies PPS to read this as INT2. Again, the interrupt is not enabled since only one should be enabled at a time. The edge polarity is then set to measure the first rising edge, and the interrupt flag is initialized to zero. 
int getTurnRight(): This is a get function which tells the other C files whether the car should turn right. If this variable is set to 1, then an obstacle is in close proximity on the left, and the car should turn right to avoid it.
int getTurnLeft(): This is a get function which tells the other C files whether the car should turn left. If this variable is set to 1, then an obstacle is in close proximity on the right, and the car should turn left to avoid it. 
void setOutput_left(): This function determines what the car should do based on the values it receives from the sensors. It first checks if the falling edge, beta, occured after the rising edge, alpha. If not, then some error has occurred, and the value should be set to an arbitrary 10000 microseconds. Otherwise, the difference divided by 16 is defined as the value in microseconds recorded between when the sensors sent a pulse and when the sensor received a pulse, according to the data sheet. If this value is less than the autostop distance but greater than the noise tolerance, the value is considered a concerning value and is stored in readings, a buffer of size 9. Another check occurs if the value is less than the turnaway distance but greater than the noise tolerance, and stores the value in farReadings. The function then checks the most recent 9 values by checking the values in both buffers. The increment variables read_sum and encroach_sum increment for the number of concerning values stored in readings and farReadings, respectively. Then, if encroach sum is less than 5, then there must not be an obstacle nearby, and turnRight is set to 0, and RB8, which is the pin connected to the LED indicator, is also set to 0. If the bot is close, but not too close to an obstacle, then read_sum will be less than 5 and enchroach_sum will be greater than or equal to 5. Then turnRight will be set to 1. Otherwise, we must be very close to an obstacle and should stop immediately. In this case, the LED indicator is turned on, the stop function is called, and collisionFront function is called. This collisionFront function essentially tells the bot to take no action until timer 5 overflows, and will be described below. Finally, the position of the pointer to the buffers is incremented, and the summation variables are reset until the next check.
void setOutput_rear(): This function decides what to do in the rear sensor case. It is very similar to the previous function, except it does not tell the car to turn because it can only sense the distance directly backwards to the nearest obstacle. As a result, it has no measurement of direction. Similar to the previous code, it checks that the falling edge has a time stamp greater than the rising edge. If so, it stores the corresponding microsecond value. If not, it stores a junk value of 10000. It then checks if the car is within the autostop distance and not subject to any noise. If so, it stores a value in the buffer that the most recent reading is concerning. It then checks the buffer to see if less than 4 of the most recent readings have been concerning. This is different than  the previous code because the reverse sensor is typically being triggered by a car moving directly towards an obstacle rather than at an angle. Thus, the smaller buffer lowers the reaction time to only needing 4 bad readings instead of 6. The buffer was then lowered because the car still needs to check that a similar percentage of readings have been concerning, so 4/6 and 5/9 are fairly similar. The logic beyond this is the same as the front sensor, as it stops the car and calls the collisionBack function if 4 or more values were too close. It also triggers the LED indicator in this case. Otherwise, it allows the car to move as normal, setting stop_rear to 0. It then increments the circular buffer pointer and clears the read_sum variable.
 void setOutput_right(): This function decides what to do with the car based on the data from the front right sensor. It is identical to the left sensor check except with different variable names corresponding to the different sensor in order to store the data for each sensor independently. It checks the fall and rise timestamps and stores the value accordingly in microseconds3. It then checks if this value should be concerning according to autostop_distance as well as turnaway_distance, and makes sure that these are outside the bounds of the noise tolerance. They are then stored in readings3 and farReadings3 accordingly. It then checks how many of the last 9 readings are concerning. If less than 5 of the encroach_sum are concerning, the car can continue as normal. If more than or exactly 5 of this but less than 5 of read_sum are concerning, it should turn away. Otherwise the car needs to stop immediately, and set collision front as well as turn on the indicator LED. The buffer pointer is then incremented and the sum variables are reset.
void collisionFront(): As mentioned briefly above, this function starts timer 5, which indicates that an obstacle is too close in the front and the car should stop immediately. It does this by setting the detectFront variable to 1, which can be used to determine if the car is allowed to move or not in other C files by calling the get function explained above. The variable will retain this value until timer 5 overflows, which is why timer 5 is turned on in this function.
 void collisionBack(): This function is called when an obstacle is detected in the back. It will set the variable detectBack to 1 and turn timer 5 on in the same way as the above function. Importantly, it will not change detectfront, nor will the above function change detectBack. This means the car can still drive forward if an obstacle is immediately behind the car, allowing the user to navigate away from the obstacle.
void setup_scan(void): This function simply sets up the sensors and timers that are necessary for this operation. It sets the clock to 16MHz as this is necessary for the correct frequency of the sensors. It also sets all of the ports to digital. It then calls all of the setup functions which were explained above.
 
Hardware
1.	PIC24FJ64GA002 Microcontroller
-	Microcontroller used
-	Up to 5 input captures and 5 output compares supported 
-	2 UART modules 
Description: The PIC was the microcontroller that was central to this assignment, and it performed dutifully. All OC’s on the module were employed and most of the timers and pins as well. It was a solid choice for a driver of the machine, but one must also consider faster chips so as to let motors be read faster, and navigation changes made sooner. For example, the Atmega64, has a clock twice as fast as the PIC and has 5V output pins, two things which hindered the PIC in how fast it could perform tasks and how much additional hardware needed to be added. This is not to say the PIC24 is awful, because it is not, but it is important to note that the choice of microcontroller matters for projects like this. In fact, at speeds that the self-driving car will eventually have to handle, there is programming at the FPGA level being performed at much faster clock speeds than a chip for a breadboard could probably handle. Ultimately, it is probably best to stay in the PIC family if doing this project for minimal effort in porting, however, the Arduino faithful probably would choose to go the way of Atmega.
Future consideration: Atmega64 or some microcontroller with a faster clock speed may cause better performance if a faster sensor is used as well.  Perhaps stick with the PIC family and get a faster one?
Link: http://ww1.microchip.com/downloads/en/DeviceDoc/39881e.pdf

2.	HC-05 Bluetooth Module
-	Operated in slave mode 
-	Default baud rate: 9600 bps
-	Interfaced with microcontroller using UART
-	Enables users to wirelessly control RC car using PC/ mobile application
Description: The HC-05 is a bluetooth module intended for small projects with an emphasis on ease of use to develop for. It connects to a microcontroller using a UART interface. This serial port bluetooth module is equipped with Bluetooth V2.0+EDR protocol and operates with a 2.4 GHz radio transceiver and baseband. Being as the commands sent to this device were single character movement instructions, it was unimportant that the data throughput of the device was minimal. It is important to note that both the HC-05 and HC-06 are valid devices for this code. A stronger ability to connect with devices would be desirable; however, the HC-05 bluetooth module has sufficiently provided seamless wireless bluetooth connection between the user and the robot car. 
Future Consideration: No alternatives to meaningfully change operation were discovered as the droid is currently designed to operate. 
Link: https://drive.google.com/file/d/0B4urklB65vaCYmxZZlJ1dmw2NzA/view

3.	HC-SR04 Ultrasonic Sensor x 3
-	sensors that provide 2 cm to 400 cm of non-contact measurement 
-	Enables robot car to avoid obstacles 
-	An echo is sent to the microcontroller if obstacle is within specified range
Description: The HC-SR04 is a part that is common across the electronic enthusiasts and gained popularity most heavily with users of the Arduino platform. It is a relatively cheap motion detecting circuit (about $4) that returns measurements accurate to about +/-0.4mm and a spread of 0.1-0.5cm (https://forum.arduino.cc/index.php?topic=243076.0)
This of course is in a laboratory setting as we learned. There are many flaws to an ultrasonic sensor being used for this type of project, namely, the harmonic distortion that occurs on irregular surfaces and the noise introduced by the circuit itself. The issues in handling irregular surfaces were severe enough to the point that the only consistent results with this sensor occurred outside on a marble surface under near perfect weather conditions. The sensors were very buggy, and interference came from many sources including but not limited to, the motors, the shape of a room, and the acoustics of a room. The testing conditions for the HC are listed in the datasheet and after reading them, it was easy to see that the sensor is not ideal for motion through any real world setting where all the surfaces are different shapes. The signals were buggy and unpredictable enough to the point that at any given time only one sensor could be reliably read. That being said, other projects have successfully utilized these sensors in a manner similar to this one, but very few have any obstacle avoidance, albeit, ours is very rudimentary. They also have a very slow polling rate compared to other sensors, and the delays necessary to filter out the notorious noise of the device and make decisions were far too long for the velocity we wished to drive the droid at, not to mention that to use these sensors, you pretty much have to have new buffer parameters for every velocity. This choice was essential to the prototype and the valuable lesson learned was that the interface of these devices with PIC is not too great, and that they are better suited for applications where dynamics are not involved. If one wishes to attempt this same droid and drive at slow consistent speeds, these sensors are ample. We suggest also purchasing the mounting brackets as we found it difficult to fashion our own. 
Future consideration: Ultrasonic sensors were far too slow to provide meaningful data. Because of this, future build should consider infrared sensors or LIDAR despite their steep costs. Furthermore, a servo sweep may be more appropriate if different sensors are used. 
Link: https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf 

4.	DC motor x 2
-	Converts direct current to mechanical movements 
Description: 
The motors we used were simple DC gearhead motors with gearing built into them such that they turned at a rate suitable for locomotion when powered. As these motors had no interface built into them, external components were required in order to power them. Namely, this was the SN754410NE H-Bridge, which allowed for bidirectional current flow through the motors, as well as allowing an intermediate device to provide the necessary voltage and current to the motors, of which the microcontroller itself was incapable.
Future Considerations: For faster operation, a motor with a larger voltage rating or brushless options will be superior.
Link: https://www.amazon.com/Smart-Chassis-Motors-Encoder-Battery/dp/B01LXY7CM3	


5.	SN754410NE H-Bridge
-	Enables voltage to be applied across the DC motors in opposite direction
-	Allow bidirectional movement of DC motors
Description: To accomplish bi-directional motion, there were a couple of options, but the one entailing the development of our own circuit using four BJT’s was not optimal in the cost of space or time developing.  This is a very standard circuit used in robotics with well-defined outputs (See: https://en.wikipedia.org/wiki/H_bridge). There are tomes on the uses of H-bridges, but the basis is that this circuit allows us to use the 3.3V outs from the PIC24 and based on how the inputs are applied, rotate individual tires in different directions. Being that this was a slip-steer, this is exactly the functioning requested. By using this circuit, the user simply must bias the terminals with one side high and the other side low causing the tire to spin with velocity control by PWM.
Future Consideration: Standard circuit, no alternatives that would meaningfully change performance were determined. 
Link: http://www.ti.com/lit/ds/symlink/sn754410.pdf

6.	CD4010BE Logic Shifter
-	Allows connection of 3.3V and 5V systems 
-	Convert microcontroller’s 3.3V to 5V to trigger ultrasonic sensors 

Description: There was a need to take the maximum 3.3V out of the PIC24 and use it to trigger the HC-SR04 which was a 5V device. The initial device used was the 2N7000 MOSFET transistor for its fast switching speed, however, at the voltage we were running, and the current sent by the PIC, there was sufficient power to switch the 5V voltage on either side of the transistor but not enough current to actually drive more than one sensor. Many attempts were made at rearranging the array, choosing different MOSFET’s like IRL520, and a BJT in 2N2222A, but it was discovered that this chip by Texas Instruments existed and cost $0.50. So, at a negligible cost in comparison to the cost of the man hours to build a decent amplifier and switching circuit, the integrated logic shifter was incorporated to translate the 3.3V pulses from the PIC into 5V trigger pulses to the HC-SR04. Ultimately this solution was very stable and outperformed all in house attempts at logic shifting. Beyond that, the chip only delays by 10nS from it’s input to output, meaning that the signal circuit makes no observable or measurable difference in the recording of the actual audio phenomena as far as we are concerned. This chip should be used for any further logic shifting in this circuit due to it’s minimal impact on timing and the fact that it can switch PIC signal voltages to 20V.
Future Consideration: No meaningful change in cost or performance was readily available at the time of publishing.
Link: http://www.ti.com/lit/ds/symlink/cd4010b.pdf
7.	Emo Smart Robot Car Chassis
-	Transparent chassis for elegant build
-	Easy installation 

Description: The base of our project was the Emo Smart Robot Car Chassis. This was really nothing more  than a plexiglass base with pre-drilled holes which allowed for the mounting of the DC gearhead motors that came with it. The chassis did not have mounting points for all of the sensors we needed or the sizable breadboard upon which the electronics of our project lived. As such, it needed to be expanded. Chassis additions included salvaged crumb trays from a toaster. They were soldered on to provide some rudimentary protection to our robot’s internal circuitry, and hold the battery packs in place. As for actually mounting our equipment, a binder clip held our breadboard to the frame, and twisted wires held the ultrasonic distance sensors to slots in the side walls. Because of the dependency on what having a particular toaster oven, and aesthetic shortfalls, it is envisioned that version two will accomplish mounting in a different fashion. The base-board was sufficient, and did mate well with the motor armatures, however, the sidewalls and the top panel for a storage location of the breadboard were not manufacturable reliably and predictably. The base board will exist in version two, but the future iterations of this droid will have different mounts for the sensors and different side walls. 
Future consideration: Buy a sturdier chassis or custom build one that fits our need. Current chassis has a wobbly caster wheel. In future build, one should plan to implement star-grounding to the chassis to prevent the possibility of electric shock and comply with electrical safety standards. This would also reduce possible circuit noise.
Link: https://www.amazon.com/Smart-Chassis-Motors-Encoder-Battery/dp/B01LXY7CM3



8.	Two Power Supplies
-	Voltage source to drive the system 
-	6V (4AA’s)  split into two power rails to power the PIC (3.3V) and ultrasonic sensors
-	7.5V (5AA’s)  to power the DC motors 

Description: The choice of a two power supply system was performed after much analysis of the efficacy of implementing a system that used one power supply. It was discovered that the motors by the very nature of their switching caused noise in the power rails sufficient to distort the HC-SR04 sensor readings. There were attempts at low-pass filtration across the power supply and shunt capacitors were applied between the motor terminals, and from the motor terminals to the case which is connected to ground. It was attempted to also use the metal parts of the chassis as ground, but this proved to cause distortions. Version two will include revisions to the case to provide a greater signal path. The 6V supply could effectively power the HC-SR04 sensors and the PIC through the use of a voltage divider to protect the PIC from violation of the voltage rating to the supply voltage. The 7.5V supply was fed into the H-Bridge as the motor supply, and it’s logic to the 6V rail. Therefore, five batteries were assigned to the motors, and four to the signal chain. The choice of AA’s provided stable power unlike 9V batteries, but this choice came at a cost of weight and space onboard the droid. Version two should look for a smaller supply for the sensors and the motors, and this most likely will be solved with different battery chemistry like Li-Po. That being said, ideally both supplies could be merged or at least the storage case for the batteries would not be two separate containers as it currently is. The current system made the droid run for about 12 hours on nine batteries with the sensor batteries failing first as the motors were not constantly drawing current from their larger supply. Furthermore, the circuitry would provide greater voltages to the motors in an ideal situation. This could be achieved with a boost converter, which in testing of the droid managed to power the motors off 2AA’S that were boosted to about 9V. Because the motors can tolerate a noisy signal, this is possible, however, the battery life would more than likely be abysmal if you were to draw enough current to drive the motors consistently on such a low power system. However, because voltage is related to rotational speed, and current to torque, it is quite possible to imagine wiring in a boost converter for the H-bridge that would provide a higher voltage in the case of less traction hindering forward motion, and raising the current to the motors to provide torque in situations where extra power is necessary. This was tested and had promise, but was not done in version one. Moreover, finding a smaller power supply for the signal chain is desirous because the power demand of the signal chain does not merit the loss of that much board space. Coin batteries may be an alternative. Ultimately, version one adopted a two power supply system with voltages decided by the number of series AA batteries because this was the cheapest and fastest way to build a reliable power circuit, which given it’s runtime, is not bad. A future model, i.e., one which calls for higher voltages to bigger motors, will not use this AA array. It should also be noted that Star-ground was still possible to implement with the signal chain and motor connections. This is because the h-bridge circuit insulated the input wires from the switching and running noise of the DC motors, thus the ground return path did not introduce sufficient noise from the motors to ground to mess with the operation of the PIC, bluetooth, or HC modules.
Future Consideration: LiPo, different battery packages, split nine-pack of batteries, ways to take less space, extend battery life, and simplify circuitry are desired. If a single power supply system can be implemented, it would be worth doing such. Furthermore, a boost converter may make operating devices require fewer batteries at the cost of operating time between charges.
Link: https://www.amazon.com/Energizer-Batteries-Battery-Alkaline-E91BP-24/dp/B004U429AQ/ref=lp_17599031011_1_2_s_it?s=hpc&ie=UTF8&qid=1525407903&sr=1-2&th=1


9. 2N222A transistor
Cheap
Common
Fast
Description: These transistors became crucial for the signal chain for their entire purpose was using the relatively small current out of the PIC24 to switch the current necessary to trigger all three sensors. A MOSFET chemistry was attempted with 2N7000, but the current throughput was not ample for the operation of more than one HC at the time, in contrast, the BJT was able to switch the trigger signal for all three HC-SR04’s. An advanced circuit analysis was not performed on the merits of this transistor beyond testing that verified it was operational and introduced minimal delay and electronic noise to the signal chain. Simply, it was the BJT most readily available due to its use in another project that needed the same type of switching (i.e. small to large current rather than small to large voltage). Because of their performance, and their prevalence in other electronics, it was deduced that this was a valid choice for transistor, and because of the function of the signal chain, no other analysis was performed.
Future Considerations: Changing from this transistor will result in minimal alterations to circuit performance, if any.
Link: https://octopart.com/2n2222a-diotec-31147100






Schematic








What's it all for?
Basic Robot Operation and Functionality Tests
	To use this library, first ensure that you have followed the wiring diagram exactly, with the most important part being that the 7.5V supply should go to the motor supply on the H-bridge, and 6V to the signal chain. Getting this wrong could damage your microcontroller.  Download the code files and flash the chip. Once you have done this, the bluetooth module on the chip will be blinking, if you had it wired in before flashing code it would’ve been flashing then, this is fine, this indicates that your HC-05 or HC-06 is ready to pair. 
	You must then open a serial terminal program such as CoolTerm, PuTTY, or a host of other serial terminal programs. The enter key should be defined as “CR+LF” and you should see the baud rate as 9600, eight data bits, no parity bits, and one stop bit. In CoolTerm it will look like this:
	
Figure 2: Serial Port Settings for CoolTerm

Figure 3: Terminal Settings for CoolTerm

Figure 4: Where you will find the HC-05 or HC-06 if it exists. 

Once you have connected, the bluetooth module should stop blinking and should instead be a solid red. If you have gotten this far, you have connected to the droid. If you are having trouble connecting and are using a Windows machine, make sure to go to your Bluetooth devices and choose the HC-05 or HC-06. Also make sure to give it a COM port as you will need this to use CoolTerm. If you are using a Mac, pair the device and your Mac will handle defining the port. In either case, if using CoolTerm, the device will show in the terminal settings as “HC-06-DevB” on a Mac and as whatever COM port you chose in Windows. 
	If you are using a computer, you should be able to press “w” and observe the tires start to move forward. If it does not move anywhere, then the room you are testing in is producing distortion of the HC-SR04 sensors, so you will either have to change the room you are in to get surfaces that are better handled by HC-SR04, or simply turn off the assistance by pressing “u”. To turn it back on, press “h”. If the tires are moving, but not as expected, one common issue is the tires spinning the opposite of the expected direction. If the wires from the PIC are in the correct inputs on the H-bridge, simply exchange the placement of the two wires going to the terminal of that respective tire and now the tire will be spinning the correct way.  If you stop pressing “w” the droid will stop, for it refreshes commands once every millisecond. It should be noted that on Windows, there is a delay after the initial key press before the key input is interpreted as a repeated input. Version 2 will attempt to fix this bug, but was extraneous to this application and simply a property of Windows itself, so it was left untouched.  Pressing “x” will also cause the droid to stop. You are currently running at full speed. To slow down the droid, press “o” and you will reduce it’s speed, “p” will increase it if there are still speeds to choose. It is recommended that a full test be performed in “user” mode to begin with to verify the operation of all peripherals. After that you can hit “h” to enter assisted mode and “u” to go back to “user” mode.  A full description of all the commands, including autoForward and autoReverse,  is summarized in Figure 1 above. 
	If the sensors are working correctly, you should be able to put a board in front of the sensors and hold it about six inches from any of the sensors. The onboard alarm LED will illuminate. If it does not, you have not wired the echo pins correctly or the sensor is possibly damaged. The reaction may be slow, and it is for this reason the version 2 will employ a different type of distance sensor. 



Advanced Robot operation
The standard mode of operation is to connect directly to the bluetooth interface of the robot using a serial terminal emulator. For our project, we used CoolTerm to control the device, but any serial terminal program would do.
For the mobile application, an open-source web application called “App Inventor” for Android was used to create a basic application to control the robot car. The two figures below show the app interface and the logic behind the operation. 

Figure 5: The Android Interface with the Car.

Figure 6: The graphical representation of our program in App Inventor


The above mobile application was tested with the robot car and was successful in controlling its motion. Building upon this idea, the above application can be expanded to include the other features such as user mode, help mode, speed up, and speed down. By using a mobile application to control the robot car, it offers the builder much more versatility as the smartphone is easier to connect with the bluetooth module than certain machines tested in development and also more convenient to carry. In addition to those legitimate practical considerations, a mobile application also increases the sophistication of the system. 
Once connected, the serial terminal was used to send commands to the robot in the form of single characters. The standard ‘w’(forward), ‘a’(left), ‘s’(backwards), and ‘d’(right) controls that may be expected when gamers are put in charge of making robots are present. In the context of our robot, left and right mean turn left and turn right, as may be expected of tank controls. Holding down these keys are necessary to move the robot, as is consistent with most video games. Before this was the case, the ‘x’ command was necessary to stop our robot, and in the current version it still does. It’s main usage now is to stop the autodrive mode of our robot.
	As the robot we have created features crash avoidance sensors, it will at default avoid collisions with objects. When objects are somewhat near, the robot will avoid by turning. However, if they get close enough that steering will not avoid a collision, the robot will respond by refusing to drive any further in the direction of the obstruction. Turning is allowed under all circumstances due to the nature of slip-steering giving the droid a turn radius of zero. The proximity limits were set as the following if the user is driving forward within 60 cm of an obstacle and the sensor finds this obstacle in at least 5 of 9 sensor checks, it will turn away from the direction of the obstacle. If the user gets within approximately 30 cm of an obstacle going either forwards or backwards, the car will stop and the user must navigate away from the object by moving in the opposite direction or in a direction that does not have any obstacles on the sensors. The sensors will give this indicator when one of the front sensors have picked up 5 of the last 9 scans as being too close, or 4 of the 6 in the rear sensor are too close. As the front sensors oscillate between left and right scan, this corresponds to approximately ½ second delay between when an obstacle is first found and when the car will stop. In the rear, this will be approximately .24 second delay. As such, it is suggested that the user only use ½ or ¾ speed in help mode. The user may also tweak the buffer checks to their specifications, the current settings are simply what worked the best in the test environment of this device, but can have variability due to room acoustics, mounting procedures, and possible electrical noise by adding modules to the car beyond the modules listed. 
The user may also exit assistance mode for added performance and greater flexibility. This is done by entering “user” mode. Activated by pressing ‘u’, user mode disables all of the sensors attached to the droid, allowing for full control over whether or not the robot comes in contact with a wall. You can re-enable the assistance with ‘h’.
Finally, the last set of controls for the droid relate to its speed. The ‘p’ key can be used to increase speed, with accompanying ‘o’ used to decrease speed. If these key commands are beginning to worry you, worry not. As it turns out, all of the information I have told you can be expressed in table form, with the below table outlining all of the keybinding for your shiny new droid. You can add more key commands to the ISR in bluetooth_defs.c to incorporate more functions, or perhaps change the keybinding, but the device does default to the table below. There are four speeds, and the default speed is set to full throttle. Advanced usage would involve adding more speeds to this array for more precise velocity control, however, it should be noted that you cannot do any better than writing “0” to the low side of the tire. One may also change the starting speed of the droid to any index by changing the element that speed initializes to in robomoto_defs.c.
As everything in this code is handled by interrupts, there is not a single way to test all of the functions at once. However, one may test each individual function by testing all of the commands listed below. To perform this test, it is recommended that the user start in user mode. This will avoid any issues with the sensors and only test the functionality of the motors. 
	First, the bluetooth connection must be established. The user must open a COM port on their computer and type in the password for their HC-05 or HC-06 bluetooth device, typically 1234. Once connection is established, the LED on the bluetooth device will move from blinking to a solid light. This will show that bluetooth_defs is working properly and that a connection has been established. This will verify setup_uart has worked to establish a connection. The following paragraphs will test the functionality of the switch statement to test all of the cases of the robot.
First, the user should push ‘u’ to enable user mode. This will show that setUserMode is working. The user can then test forward, backward, and left and right cases according to the table below. These should all perform from the OC_Moto as well as bluetooth defs, but will not use motiondetect yet. This will call and verify the functions forward, backward, left, and right. If the user lets go of any of these buttons, the car will stop after a small delay. This will show that timer 4 interrupt is working as a signal length, showing how long the car should execute a driving function with a certain input from the computer. To test speed, the user should push ‘o’ and test the direction buttons again, then repeat this two more times to test all four speeds. The user should then press ‘p’ to increment the speed, test the directions, and repeat two more times to again test all four speeds in the increment case. This will test the speed functions speedUp and speedDown within  OC_Moto. These tests will show that OC2, 3, 4, and  5 are all working as PWM signals for the left motor reverse, left motor forward, right motor backward, and right motor forward, respectively. It will also show that timer 2 interrupt flag is properly set up to work with these output compares. From there, the user should press ‘e’ or ‘q’ to test the cruise control functions within OC_Moto. It is important that the user test this in an open area, as the car will move forever without stopping in user mode. This will verify the autoForward and autoReverse functions. The stop function within OC_Moto can then be tested by pressing ‘x’ at any time, most explicitly during the cruise. 
	Once the functions of OC_Moto have been tested, the user should press ‘h’ to test the help mode. This will verify that the sensors are working properly. First, the car should be placed in close proximity to a wall without moving. The LED indicator should either be a solid light or a very rapid blinking light. This will show that the sensors are picking up good data and that OC1 is working. This can also be verified by listening to a slight clicking noise coming from any of the sensors. This will also show that timer 3 interrupt flag is set up properly as the trigger for the sensors, as the sensors are sending out a signal properly. The user should then tap the ‘w’ button to activate the front sensors. Then, the user can place their hand in front of either of the sensors. The LED indicator will turn on and blink rapidly. This shows that interrupts int0 and int2 are switching, as one is setting the LED off since it does not detect an obstacle on one sensor, which will attempt to turn the LED off, but it will detect an obstacle on the other sensor, which will attempt to turn the LED on. Then, the user should push the ‘s’ key, and perform the same test by placing their hand on the rear sensor. This should cause a solid LED light to appear. These tests will show that int0, int1, and int2 are all working, and are also correctly calling setOutputLeft, setOutputRight, and setOutputRear, respectively From there, the user should test the same directional buttons starting from a location with no obstacles. The user should have no problems with driving in this case. Then the user should approach an obstacle with the forward key. The car will turn away from the obstacle when it gets too close, showing that getTurnRight and getTurnLeft work properly. The user should repeat this test from both directions to prove that both sensors are working. Next, the user should reverse towards the obstacle instead. The car should get much closer to the obstacle before reacting, but stop completely after getting too close. This will show that setOutput_rear is working as well as collision rear. Finally, the user should place the car next to an obstacle and attempt to drive forwards. The car should not move forwards and the LED indicator should be blinking rapidly. This test should be performed from a variety of orientations as long as the sensors are generally facing the obstacle. This will show that setOutput_Left/Right and collision front are working. This will indirectly test the timer 1 interrupt flag is working properly, as it is used to store the overflow as well as the timestamps of the sensors. If the obstacle is removed, the car should be allowed to move in approximately 750 ms. This will show that the timer 5 interrupt is operating properly. This delay will occur whether the user places the obstacle in front of the car or behind it. This shows that collsionFront and collisionBack are working, respectively. Also, if the car is near an obstacle in any direction, the car should still be allowed to turn. Finally, if cruise control is enabled with either ‘q’ or ‘e’, then the car should only stop if it gets too close, but will not turn away in any of these cases. These cases will verify all of the possible if statements within setOutput_left, setOutput_right, and setOutput_rear. All of these tests will show that the bluetooth chip is correctly interpreting these functions, and the interrupts are operating properly. This will indirectly test the bluetooth_defs because every case of the switch statement will have been tested. Using these tests, all of the functions of the car can be explored and verified to be working. 

w
Forwards
a
Left (pivot turn)
s
Backwards
d
Right (pivot turn)
x
Stop
e
Auto-drive forward (avoids objects if user mode is off)
q
Auto-drive backwards (avoids objects if user mode is off)
u
Enable user mode (turn off collision avoidance)
h
Disable user mode (sensors now prevent collisions (mostly))
p
Increase driving speed
o
Decrease driving speed.
 
